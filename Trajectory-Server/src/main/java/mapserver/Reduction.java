
package mapserver;

import java.util.ArrayList;
import java.util.List;

/**
 * Reduction operation class
 *
 */
public class Reduction {
    /**
     * Reduces the set of incoming points using the epsilon value. Assigns 
     * the results to the list in parameter 3 sent to it.
     * 
     * @param points List of points to reduce
     * @param epsilon Epsilon value
     * @param output List of the results to be created after the operations
     */
    public static void DouglasPeucker(List<mapclient.Point> points, double epsilon, List<mapclient.Point> output) {
        // Reduction is not possible if the number of dots is less than 2.
        if(points.size() < 2) {
            throw new IllegalArgumentException("Not enough points!");
        }
        double maxDistance = 0.0;   // Maximum vertical distance
        int index = 0;  // Index of the point with the maximum vertical distance
        int end = points.size() - 1;    // Index of the last point on the list
        
        for (int i=1; i<end; ++i) {
            /**
             *  To find the maximum vertical distance between the start and end point, 
             * the data in the list is sent individually to the vertical distance function.
            */ 
            double d = perpendicularDistance(points.get(i), points.get(0), points.get(end));
            if(d > maxDistance) {
                index = i;
                maxDistance = d;
            }
        }

        // If the max distance is greater than the epsilon, recursively simplify.
        if(maxDistance > epsilon) {
            // List holding the points between the starting point and the current point as a result of the transaction
            ArrayList<mapclient.Point> result1 = new ArrayList<>(); 
            // List holding the points between the current point and the endpoint as a result of the actions
            ArrayList<mapclient.Point> result2 = new ArrayList<>();
            
            // All points between the starting point and the current point
            List<mapclient.Point> firstLine = points.subList(0, index +1);
            // All points between the current point and the end
            List<mapclient.Point> lastLine = points.subList(index, points.size());
            
            // Recursively reduces the starting point and the current point.
            DouglasPeucker(firstLine, epsilon, result1);
            // Özyinelemeli olarak geçerli nokta ile bitiş noktasını baz alarak indirgeme yapar.
            DouglasPeucker(lastLine, epsilon, result2);
            
            // Assigns all current results to the output list.
            output.addAll(result1.subList(0, result1.size() - 1));
            output.addAll(result2);
            
        } else {
            /**
             * If the current maximum vertical distance is less than or equal to the 
             * epsilon, then that step of the recursion stops, and the result list in 
             * that step is added to the start and end value in that step.
             */
            output.clear();
            output.add(points.get(0));
            output.add(points.get(points.size() - 1));
        }     
            
    }

    /**
     * Returns the vertical distance from the current point to an imaginary 
     * line that joins the beginning and end points.
     * 
     * @param currentPoint Current point info
     * @param startPoint Start point
     * @param endPoint End point
     * @return 
     */
    private static double perpendicularDistance(mapclient.Point currentPoint, mapclient.Point startPoint, mapclient.Point endPoint) {
        
        // Latitude and longitude differences of the start and end point
        double x = endPoint.getLatitude() - startPoint.getLatitude();
        double y = endPoint.getLongitude() - startPoint.getLongitude();
        
        // Normalization process
        double h = Math.hypot(x, y);    // sqrt(x^2 + y^2)
        if(h > 0.0) {
            x /= h;
            y /= h;
        }
        
        double pX = currentPoint.getLatitude() - startPoint.getLatitude();
        double pY = currentPoint.getLongitude() - startPoint.getLongitude();

        // Scalar multiplication (current point looks at normalized direction)
        double pDot = x*pX + y*pY;
        
        // The scaled vector is removed from the existing direction vector.
        double aX = pX - pDot*x;
        double aY = pY - pDot*y;
               
        // The hypotenuse of the points gives us the vertical distance.
        return Math.hypot(aX, aY);
    }
    /**
     * (1-(Number of data generated as a result of reduction/Number of raw data))*100 
     * returns the result of the operation as a double. This process gives us the reduction rate.
     * 
     * @param crudedSize Number of raw data
     * @param processedSize Number of data generated by reduction
     * @return 
     */
    public static double calculateReductionRate(int crudedSize, int processedSize) {
        return ((1.0 - (double) processedSize/crudedSize)*100.0);
    }
}
